This file contains the man pages for those programs not listed in the book or
which have been significantly modified since the first release.  It should be
installed as /usr/lib/helpfile.
---------------------------------------------------------------------------

# animals
Command:	animals - twenty questions type guessing game about animals
Syntax:		animals [database]
Flags:		(none)
Example:	animals

     Animals is a guessing game.  The user picks an animal and the computer
tries to guess it by posing questions that should be answered by typing "y"
for yes and "n" for no.  Whenever the computer loses, it asks some questions
that allow it to improve its data base, so as time goes on, it learns.  The
default data base should be in /usr/lib/animals.


# ar
Command:	ar - archiver
Syntax:		ar [qrxdpmt][abivulc] [posname] archive file ...
Flags:		(none)
Examples:	ar r libc.a sort.s	# replace sort.s in libc.a
		ar rb a.s libc.a b.s	# insert b.s before a.s in libc.a

     Ar allows groups of files to be put together into a single archive.
It is normally used for libraries of compiled procedures.  The following keys
are allowed:
	  q: quickly append to the end of the archive file.
	  m: move named files. Ar expects 'a', 'b', or 'i' to be specified.
	  r: replace (append when not in archive).
	  d: delete. Ar will delete the name members.
	  t: print the archive's table of contents.
	  p: print the named files (list them on standard output)
	  x: extract

The keys may optionally concatencated with one or more of the following:
	  l: local temporary file for work instead of /tmp/ar.$$$$$
	  v: verbose
	  a: after 'posname'
	  b: before 'posname'
	  i: before 'posname'
	  c: create  (suppresses creation message)
	  u: replace only if dated later than member in archive


# ascii
Command:	ascii - strip all the pure ASCII lines from a file
Syntax:		ascii [-n] [file]
Flags:		-n Extract the lines containing nonASCII characters
Examples:	ascii file >outf	# put all the ASCII lines on outf
		ascii -n <file >outf	# write nonASCII lines to outf

     Sometimes a file contains some nonASCII characters that are in the way.
This program allows the lines containing only ASCII characters to be grepped
from the file.  With the -n flag, the nonASCII lines are grepped.  No matter
whether the flag is used or not, the program returns an exit status of true
if the file is pure ASCII, and false otherwise.


# ast
Command:	ast - add symbol table to executable file
Syntax:		ast -xX [file] [symbol_file]
Flags:		-x do not preserve local symbols
		-X preserve local symbols (except compiler generated ones)
Example:	ast -X a.out		# add symbols from symbol.out to a.out

    Ast adds the symbol table produced by the -s option of asld to the 
executable file.  If no symbol table file is listed, the default name 
'symbol.out' is used.  The symbol table can be generated by the command
cc -s file.c >symbol.out.


# at
Command:	at - execute commands at a later time
Syntax:		at time [month day] [file]
Flags:		(none)
Examples:	at 2315 Jan 31 myfile	# myfile executed Jan 31 at 11:15 pm
		at 0900			# job input read from stdin
		at 0711 4 29 		# read from stdin, exec on April 29

     At prepares a file to be executed later at the specified time by creating
a special entry in /usr/spool/at.  The program atrun should be started 
periodically, for example, every minute by cron.  Atrun checks to see if any
files in /usr/spool/at should now be run, and if so, it runs them and then puts
them in /usr/spool/at/past.  The name of the file created in /usr/spool/at by 
at is YY.DDD.HHMM.UU (where YY, DDD, HH, and MM give the time to execute and 
UU is a unique number).  Note that when the command runs, it will not be able 
to use standard input or standard output unless specifically redirected.  In 
the first example above, it might be necessary to put >/dev/tty0 on some lines
in the shell script myfile.  The same holds for the commands typed directly to
at.


# badblocks
Command:	badblocks - put a list of bad blocks in a file
Syntax:		badblocks block_special
Flags:		(none)
Example:	badblocks /dev/fd1

     If a device develops bad sectors, it is important to not have them
allocated to important files.  This program makes it possible to collect
up to 7 bad blocks into a file, so they will not be allocated for a "real"
file.  When the program starts up, it asks for a list of bad blocks.  Then
it creates a file whose name is of the form .Bad_xxxxx, where xxxxx is a pid.

# banner
Command:	banner - print a banner
Syntax:		banner arg ...
Flags:		(none)
Example:	banner happy birthday	# print a banner saying happy birthday

     Banner prints its arguments on standard output using a matrix of 6 x 6
pixels per character.  The @ sign is used for the pixels.


# cal
Command:	cal - print a calendar
Syntax:		cal [month] year
Flags:		(none)
Example:	cal 3 1987		# print March 1987

     Cal prints a calendar for a month or year.  The year can be between 1
and 9999.  Note that the year 87 is not a synonym for 1987, but is itself a
valid year about 19 centuries ago.  The calendar produced is the one used
by England and her colonies.  Try Sept. 1752, Feb 1900, and Feb 2000.  If
you don't understand what is going on, look up "Calendar, Gregorian" in a
good encyclopedia.


# cdiff
Command:	cdiff - context diff
Syntax:		cdiff [-c] old new
Flags:		-cN how much context to provide
Example:	cdiff old new >f	# write context diff on f

     Cdiff produces a context diff by first running 'diff' and then adding
context.  Some update programs, like patch, can use context diffs to update
files, even in the presence of other, independent changes.


#chmod
Command:  chmod - change access mode for files
Syntax:   chmod octal-number files
          chmod [augo][+-=][rwxst] files
Flags:    (none)
Examples: chmod 755 file            # Owner: rwx Group: r-x Others: r-x
          chmod +x file1 file2      # Make file1 and file2 executable
          chmod a-w file            # Make file read only
          chmod u+s file            # Turn on SETUID for file
          chmod g=u                 # group perms set to same as user perms.

     The given mode is applied to each file in the file list.  The mode can be 
either absolute or symbolic.  Absolute modes are given as an octal number
that represents the new file mode.  The mode bits are defined as follows: 
        4000    Set effective user id on execution to file's owner id
        2000    Set effective group id on execution to file's group id
        0400    file is readable by the owner of the file
        0200    writeable by owner
        0100    executable by owner
        0070    same as above, for other users in the same group
        0007    same as above, for all other users

Symbolic modes modify the current file mode in a specified way.  They take
the form: 
        [who] op permissions { op permissions }
The possibilities for [who] are 'u', 'g', 'o', and 'a'; standing for user, 
group, other and all, respectively.  If who is omitted, 'a' is assumed, but 
the current umask is used.  The op can be '+', '-', or '=';  '+' turns on the 
given permissions, '-' turns them off; '=' sets the permissions exclusively
for the given who.  For example 'g=x' sets the group permissions to '--x'. 
     The possible permissions are 'r', 'w', 'x'; which stand for read, write, 
and execute;  's' turns on the set effective user/group id bits.  'u', 
'g' and 'o' in the permissions field stand for the current user, group, or
other permission bits, respectively.  Only one of these may be used at a time.
's' only makes sense with 'u' and 'g'; 'o+s' is harmless and does nothing. 
Multiple symbolic modes may be specified, separated by commas.


# compress
Command:	compress - compress a file using modified Lempel-Ziv coding
Syntax:		compress [-cdfv] [file] ...
Flags:		-c Put output on standard output instead of on file.Z
		-d Decompress instead of compress
		-f Force output even if there is no saving
		-v Verbose mode
Examples:	compress <infile >outfile	# compress 1 file
		compress x y z	# compress 3 files to x.Z, y.Z, and z.Z

     The listed files (or standard input, if none are given) are compressed
using the Ziv-Lempel algorithm.  If the output is smaller than the input,
the output is put on file.Z or standard output if no files are listed.  If
compress is linked to uncompress, the latter is the same as "compress -d".
Similarly, a link to "zcat" decompresses to standard output.


# cpdir
Command:	cpdir - copy a directory and its subdirectories
Syntax:		cpdir [-v] srcdir destdir
Flags:		-v Verbose; cpdir tells what it is doing
Example:	cpdir dir1 dir2	# creat dir2 and copy dir1's files into it

     Cpdir creates the target directory, goes into it, and copies all the
files in the source directory to it.  When it is done, the target directory
contains the same files as the source directory.  Subdirectories are copied
Recursively. Links and special files are ignored.


# cron
Command:	cron - clock daemon
Syntax:		cron
Flags:		(none)
Example:	/usr/bin/cron		# use absolute path in /etc/rc

     Cron is clock daemon.  It is typically started up by including the
command /usr/bin/cron in the /etc/rc file.  Once started, cron puts itself
in the background, so no & is needed.  It runs forever, sleeping most of
the time.  Once a minute it wakes up and examines /usr/lib/crontab to see
if there is any work to do.  If there is, the work is done.  The entries of
/usr/lib/crontab contain 6 elements each.  Some examples follow:

   min hr dat mo day   command
    *  *   *  *   *    /usr/bin/date >/dev/tty0   #print date every minute
    0  *   *  *   *    /usr/bin/date >/dev/tty0   #print date on the hour
   30  4   *  *  1-5   /bin/backup /dev/fd1       #do backup Mon-Fri at 0430
   30 19   *  *  1,3,5 /etc/backup /dev/fd1       #Mon, Wed, Fri at 1930
    0  9  25 12   *    /usr/bin/sing >/dev/tty0   #Xmas morning at 0900 only


# diff
Command:	diff - print differences between two files
Syntax:		diff file1 file2
Flags:		(none)
Example:	diff file1 file2	# print differences between 2 files

     Diff compares two files and generates a list of lines telling how
the two files differ.  Lines may not be longer than 128 characters.


# diskcheck
Command:	diskcheck - check a disk for bad sectors
Syntax:		diskcheck device start count
Flags:		(none)
Examples:	diskcheck /dev/at0 0 1200	# check 1.2 MB floppy
		diskcheck /dev/at0 100 1100	# check floppy from block 100

     Diskcheck checks a disk for bad sectors by reading in each sector,
writing a known bit pattern onto it, reading it back in and comparing with
what was written.  This check is then done a second time.  Bad sectors are 
reported.  After each sector is tested, the original sector is restored.


# dis88
Command:	dis88 - disassembler
Syntax:		dis88 [-o] infile [outfile]
Flags:		-o List the object code along with the assembly code
Examples:	dis88 a.out >listing		# disassemble a.out
		dis88 -o a.out listing		# ditto, but with object code

     Dis88 is a disassembler.  It takes an executable file and prints the
symbolic assembly code that corresponds to it.  If the executable file contains
a symbol table (added by the program ast), the symbol table information is used
to give a more readable asembly listing.


# dosdir
Command:	dosdir - read a DOS directory
Syntax:		du [-lr] drive dir
Flags:		-l long
		-r recursive
Example:	dosdir -l c		# list drive c

     Dosdir/dosread/doswrite have been extended to handle hard disks using the
letters c,d,e, and f.  The letters a and b can be used for floppies as synonyms
for 0 and 1.


# du
Command:	du - print disk usage
Syntax:		du [-s] dir
Flags:		-s Summary only
Example:	du dir			# list disk space used by files in dir

     Du examines a directory and prints the amount of space occupied by the
files in that directory and its subdirectories.


# ed
Command:	ed - editor
Syntax:		ed file
Flags:		(none)
Example:	ed prog.c		# edit prog.c

    Ed is functionally equivalent to the standard V7 editor, ed.  It supports
the following commands:
	
	(.)	a: append
	(.,.)	c: change
	(.,.)	d: delete
		e: edit new file
		f: print name of edited file
	(1,$)	g: global command
	(.)	i: insert
	(.,.+1)	j: join lines together
	(.)	k: mark
	(.)	l: print with special characters in octal
	(.,.)	m: move
	(.,.)	p: print
		q: quit editor
	(.)	r: read in new file
	(.,.)	s: substitute
	(1,$)	v: like g, except select lines that do not match
	(1,$)	w: write out edited file

Many of the commands can take one or two addresses, as indicated above.  The
defaults are shown in parentheses.  Thus 'a' appends to the current line, and
g works on the whole file as default.  The dot refers to the current line.
Below is a sample editing session with comments given following the # symbol.
	ed prog.c		# edit prog.c
	3,20p			# print lines 3 through 20
	/whole/			# find next occurence of 'whole'
	s/whole/while/		# replace 'whole' by 'while'
	g/MAXBUF/s//MAX_BUF/g	# replace 'MAXBUF' by 'MAX_BUF' everywhere
	w			# write the file back
	q			# exit the editor
	

# expr
Command:	expr - evaluate experession
Syntax:		expr arg ...
Flags:		(none)
Example:	x=`expr $x + 1`		# add 1 to shell variable x

     Expr computes the value of its argument and writes the result on
standard output.  The valid operators, in order of increasing precedence,
are listed below.  Operators grouped by {...} have the same precedence.
Operators: |, &, {<, <=, ==, !=, >=, >}, {+, -}, *.
     Note that the V7 ":" operator is missing.  Parentheses are permitted.


# factor
Command:	factor - factor an integer less than 2**31
Syntax:		factor number
Flags:		(none)
Example:	factor 450180	# print the prime factors of 450180

     Factor prints the prime factors of its argument in increasing order.
Each factor is printed as many times as it appears in the number.


# fgrep
Command:	fgrep - fast grep
Syntax:		fgrep [-cfhlnsv] [file] [string] [file] ...
Flags:		-c count matching lines and only print count, not the lines
		-f take strings from file named in following argument
		-h omit file headers from printout
		-l list file names once only
		-n each line is preceded by its line number
		-s status only, no output
		-v print only lines not matching
Examples:	fgrep # prog.c			# print lines containing # sign
		fgrep -f pattern prog.c		# take strings from 'pattern'

     Fgrep is essentially the same as grep, except that it only searches for
lines containing literal strings (no wildcard characters), and it is much
faster.


# file
Command:	file - make a guess as to a file's type based on contents
Syntax:		file name ...
Flags:		(none)
Example:	file a.out /usr/include/ar.h	# guess at types

     File reads the first block of a file and tries to make an intelligent
guess about what kind of file it is.  It understands about archives, C
source programs, executable binaries, shell scripts, and English text.


# find
Command:	find - find files meeting a given condition
Syntax:		find directory expression
Flags:		(none)
Examples:	find /  -name a.out -print	# print all a.out paths
		find /usr/ast ! -newer f -ok rm {} \;	# ask before removing
		find /usr -size +20 -exec mv {} /big \; # move files > 20 blks
		find / \( -name a.out -o -name `*.o` \) -exec rm {}\;

     Find descends the file tree starting at the given directory checking
each file in that directory and its subdirectories against a predicate.
If the predicate is true, an action is taken.  The predicates may be
connected by -a (Boolean and), -o (Boolean or) and ! (Boolean negation).
Each predicate is true under the conditions specified below.  The integer n
may also be +n to mean any value greater than n, -n to mean any value less than
n, or just n for exactly n.
  -name s	true if current filename is s (include shell wild cards)
  -size n	true if file size is n blocks
  -inum n	true if the current file's i-node number is n
  -mtime n	true if modification time relative to today (in days) is n
  -links n	true if the number of links to the file is n
  -newer f	true if the file is newer than f
  -perm n	true if the file's permission bits = n (n is in octal)
  -user u	true if the uid = u (a numerical value, not a login name)
  -grogp g	true if the gid = g (a numerical value, not a group name)
  -type x	where x is bcdfug (block, char, dir, regular, setuid, setgid)

Following the expression can be one of the following, telling what to do
when a file is found:
  -print	print the file name on standard output
  -exec		execute a MINIX command, {} stands for the file name
  -ok		prompts before executing the command


# fdisk
Command:	fdisk - partition a hard disk
Syntax:		fdisk file
Flags:		(none)
Example:	fdisk /dev/hd1

     When fdisk starts up, it reads in the partition table and displays it.
It then presents a menu to allow the user to modify partitions, store the
partition table on a file, or load it from a file.  Partitions can be marked
as DOS or non-DOS, and active or not.  MINIX doesn't care what kind of a
partition it uses.  Using fdisk is self-explanatory.  However, be aware that
repartitioning a disk may cause information on it to be lost.  Rebooting the
system is mandatory after changing partition sizes.  MINIX, XENIX, PC-IX, and
MS-DOS all have different ideas about how partitions are numbered.


# fix
Command:	fix - generate new file from old one and diff listing
Syntax:		fix oldfile difflist >newfile
Flags:		(none)
Example:	fix old difflist >new	# generate new from old and diffs

     Fix accepts a diff listing produced by diff and reconstructs the
new file.  It is common for people to take a file, modify it, and then
send the diff listing between the old and new files to other people.
Using fix, the old file, and the diff listing, it is possible to creat
the new file.  For example:

  diff oldfile newfile >difflist
  fix oldfile difflist >new2

will generate a file new2 that is identical to newfile.


# from
Command:	from - input half of a connection
Syntax:		from port
Flags:		(none)
Examples:	from port | sort >x	# fetch and sort an incoming file
		from port | sh		# primitive sherver

     To and from are used together to provide connection-oriented service.
On the sending machine, the last member of a pipeline is 'to port'.  On the
receiving machine, the first member of a pipe line is 'from port'.  The net
result is that the output of the sending pipeline goes into the input of the
receiving pipeline, making pipelines work across the network. 


#fsck
Command:   	fsck - perform file system consistency check
Syntax:	   	fsck [-aclmrs] [device] ...
Flags:	   	-a automatically repair inconsistencies
	   	-c inode ...	check and list only the specified inodes
	 	-l list the files and directories in the filesytem
	  	-m make a new file system
	   	-r prompt user for repairs if inconsistencies are found
	  	-s list the superblock of the file system
Examples: 	fsck /dev/hd4	# check file system on /dev/hd4
	 	fsck -a /dev/at0	# automatically fix errors on /dev/at0
	   	fsck -l /dev/fd0	# list the contents of /dev/fd0
	   	fsck -c 2 3 /dev/hd3	# check and list /dev/hd3 inodes 2 & 3

     Fsck performs consistency checks on the file systems which reside on the
specified devices.  It may also be used to list the contents of a file system 
or to make a new file system.  Fsck can be run from the initial menu and during
normal production.  The number of heads and sectors/track are built in to 
the program (4 and 17, respectively).  To change these, modify the code and
recompile.  If they are set wrong, fsck will give absurd errors.


# help
Command:	help - give help about a command
Syntax:		help [name]
Flags:		(none)
Example:	help uuencode

     Help gives help about a given command name (or help itself, if none is
specified).  It gets its information from /usr/lib/helpfile, which should be
linked to doc/man_pages.  To improve performance, it builds an index file,
/usr/lib/helpfile.idx, which is updated when it is observed to be older than
/usr/lib/helpfile.  The lines beginning with # are the keywords for help.
The helpfile contains all the manual pages not present in the book.


# lorder
Command:	lorder - compute the order for library modules
Syntax:		lorder file ...
Flags:		(none)
Example:	lorder proc1.s proc2.s

     Lorder accepts a series of packed or unpacked .s files and libraries,
and produces a partial ordering suitable for processing by tsort.


# master
Command:	master - control the creation of shervers
Syntax:		master count uid gid command
Flags:		(none)
Example:	master 2 1 1 /usr/bin/sherver port

     If a machine is intended to be used as a server, its /etc/rc file should
have a command similar to the example above.  When the system is booted, master
runs and forks off the required number of shervers (max 4).  They run with the
indicated uid and gid, and listen to the indicated port.  When an rsh is done
on a client machine, the command is given to one of the shervers for execution.
When the sherver is done, it exits, master, which is always running, sees this,
and creates a new sherver.  Thus master is very similar to init, only it makes
new shervers (usually) instead of new login programs.  Master must run as root
to be able to do setuid and setgid.

# more
Command:	more - pager
Syntax:		more file ...
Flags:		(none)
Example:	more file		# display file on the screen

     More is an alternative to mined as a pager, for people used to the
4.x BSD pager.  This version only implements three commands:
   <space>  - display next page
   <return> - display next line
   q        - exit more


# nm
Command:	nm - print name list
Syntax:		nm [-gnopru] [file] ...
Flags:		-g print only external symbols.
		-n sort numerically rather than alphabetically.
		-o prepend file name to each line rather than only once.
		-p don't sort, print in symbol-table order.
		-r sort in reverse order.
		-u print only undefined symbols.
Examples:	nm -n a.out		# print all symbols in numerical order
		nm -g a.out		# print global symbols alphabetically

    Nm prints the symbol table of executable files when it is available.
If no file is given, the symbols in a.out are used.  The format of the table 
is somewhat compatible with the one produced  by asld when used with the -s 
option. The symbol table can be added with ast.  Archives are not supported. 
Note that assembly language files don't have symbol tables.


# paste
Command:	paste - paste multiple files together
Syntax:		paste [-s] [-ddelim] file ...
Flags:		-s print files sequentially, file k on line k
		-ddelim set delimiter used to separate columns
Examples:	paste file1 file2	# print file1 in col 1, file2 in col 2
		paste -s f1 f2 f3 f4	# print f1 on line 1, f2 on line 2, etc

     Paste displays multiple files in parallel.  Suppose a set of k files each
have one word per line.  Then the paste output will have k columns, with the
contents of file j in column j.  The columns are separate by tabs unless the
separator is changed with the -d flag.  If the -s flag is given, then the first
file is on line 1, the second file on line 2, etc.  In effect, -s turns the
files sideways.


# patch
Command:	patch - patches up a file from the original and a diff
Syntax:		patch [-bcdDefFlnNop]
Flags:		-b next argument is backup extension, instead of .orig
		-c interpret the patch file as a context diff
		-d cd to the next arg (assumed a dir) before doing anything
		-D mark changes with "#ifdef...#endif"; next arg gives label
		-e interpret the patch file as an ed script
		-f forces patch to do its work without asking any questions
		-F# sets the maximum fuzz factor
		-l do matching loosely (e.g., all white space is equivalent)
		-n interpret the patch file as a normal diff
		-N ignore patches that are reversed or already applied
		-o next argument is the output file name
		-p# sets the pathname strip count
Example:	patch file difflist		# fix up the file

     Patch takes an original file and a diff listing and recreates the new
file.  It is functionally similar to fix, but much more powerful.  Not only
can it handle normal diffs, but also context diffs produced by cdiff.  In
addition, it works even when the file being patched has other changes to it.
It deduces the type of difflist itself (unless given -c, -e, or -n).
The normal usage is given in the example above.  In this case patch will
modify 'file' to incorporate all the patches.  The original file will be put
on 'file~.


# prep
Command:	prep - prepare a text file for statistical analysis
Syntax:		prep [file]
Flags:		(none)
Examples:	prep infile >outfile		# prep infile
		prep <infile >outfile		# prep infile

     Prep strips off most of the troff commands from a text file and then
outputs all the words, one word per line, in the order they occur in the file.
This file can then be sorted and compared to a dictionary (as a spelling
checker), or used for statistical analyses.


# printenv
Command:	printenv - print out the current environment
Syntax:		printenv
Flags:		(none)
Example:	printenv		# print the environment

     Printenv prints out the current environment strings, one per line.


# rcp
Command:	rcp - remote copy
Syntax:		rcp [mach1]!file1 [mach2]!file2
Flags:		(none)
Examples:	rcp file mach1!/usr/ast/x	# local file to remote machine
		rcp mach2!/usr/ast/x file	# fetch remote file

     Rcp is not a program.  It is a shell script that does remote copying.  It
makes use of the programs 'to' and 'from'.


# readall
Command:	readall - read a device quickly to check for bad blocks
Syntax:		readall file
Flags:		(none)
Example:	readall /dev/hd0		# read all of /dev/hd0

     Readall reads all of the named device in large chunks.  It reports about
blocks that it cannot read.  Unlike diskcheck, it does not attempt to write on
the disk, making it "safer" to use when one is worried about a sick system.


# readclock
Command:	readclock - read the AT's real time clock
Syntax:		readclock
Flags:		(none)
Example:	date `/usr/bin/readclock` </dev/tty	# useful in /etc/rc

     Readclock reads the AT's real time clock and prints the result in a form
useful to date, namely, MMDDYYhhmmss.  If the clock does not exist (e.g., on a
PC), it outputs "-q" to query the user for the time.  The example given above
can be put in /etc/rc to load the real time when the system is booted.


# readfs
Command:	readfs - read a MINIX file system
Syntax:		readfs [-il] block_special [dir]
Flags:		-i Give information about the file, but do not extract files
		-l List the files extracted on standard output
Example:	readfs -l /dev/fd0

     Readfs reads a floppy disk containing a MINIX file system.  It can
extract all the files from it, give a listing of them, or both.  The files
extracted can be put in a user-specified directory (default: current
directory).  If subdirectories are needed, they will be created automatically.


# rsh
Command:	rsh - remote shell for networking
Syntax:		rsh port [-beil]
Flags:		-b start the rsh in the background
		-e keep stderr separate from stdout
		-i take input from the local process
Examples:	rsh machine5 ls -l /usr/bin	# list remote bin directory
		rsh abc cat /usr/doc/f >f	# fetch remote file
		rsh foobar			# log onto remote machine

     The remote shell command is the way to have a distant server carry out
a command over the Ethernet.  The port given as the first argument can be
any string of up to 6 characters, but it must match the port used by some
sherver.  The command will be executed and the results returned on stdout.
Unless the -e flag is given, the remote stderr and stdout are merged onto the
local stdout.  Giving rsh with just a port and no argument is the standard way
to log onto a remote machine.


# sherver
Command:	sherver - shell server
Syntax:		sherver port
Flags:		(none)
Example:	sherver machine1

     The rsh command does its remote execution by doing a remote procedure call
to some sherver.  The sherver executes the command and then exits.  Usually a
master will be running to make a new one.  Because shervers get their input 
from a pipe, remote execution cannot handle signals and CTRL-D, because they
cannot be sent down a pipe.


# spell
Command:	spell - print all words in a file not present in the dictionary
Syntax:		spell file
Flags:		(none)
Example:	spell document		# print the spelling errors on stdout

     Spell is the MINIX spelling checker.  It is actually a short shell script.
First, the program prep strips off the roff, nroff, and troff control lines,
and the punctuation, and lists each word on a separate line.  These words are
then sorted.  The resulting output is then compared to the dictionary.  Words
present in the file but not present in the dictionary are listed.  The
dictionary should be located in /usr/lib (or the shell script changed).


# strings
Command:	strings - print all the strings in a binary file
Syntax:		strings file ...
Flags:		-			# search whole file, not just data seg
		-o			# print octal offset of each string
		-n			# n is minimum length string (def. = 4)
Examples:	strings -5 a.out	# print the strings >= 5 chars in a.out
		strings - /bin/sh	# search entire shell file

     Strings looks for sequences of ASCII characters followed by a zero byte.
These are usually strings.  This program is typically used to help identify
unknown binary programs


# strip
Command:	strip - remove symbol table from executable file
Syntax:		strip [file] ...
Flags:		(none)
Example:	strip a.out		# remove symbols from a.out

    For each file argument, strip removes the symbol table.  Strip makes a 
copy of the file being stripped, so links are lost.


# term
Command:	term - turn PC into a dumb terminal
Syntax:		term [baudrate] [parity] [bits_per_character]
Flags:		(none)
Examples:	term 2400		# talk to modem at 2400 baud
		term 1200 7 even	# 1200 baud, 7 bits/char, even parity
		term 8 9600		# 9600 baud, 8 bits/char, no parity

     Term allows MINIX to talk to a terminal or modem over RS232 port 1.  The
program first sets the baudrate, parity and character length, and then forks.
The parent sits in a loop copying from standard input (usually the console's
keyboard), to the terminal or modem (/dev/tty1).  The child sits in a loop
copying from the terminal or modem (/dev/tty1) to standard output.  Thus when
RS232 port 1 is connected to a modem, every keystroke typed on the keyboard
is sent to the modem, and every character arriving from the modem is displayed.
Standard input and output may be redirected, to provide a primitive file
transfer program, with no checking.  To exit term, type three ESC characters.
Important note: to use term, it is essential that /etc/ttys is configured so
that there is no shell hanging on /dev/tty1.  If there is, both the shell and
term will try to read from /dev/tty1, and nothing will work.


# termcap
Command:	termcap - print the current termcap entry
Syntax:		termcap [type]
Flags:		(none)
Example:	termcap			# print the termcap entry

     Termcap reads the /etc/termcap entry corresponding to the terminal type
supplied as the argument.  If none is given, the current $TERM is used.
It then prints out all the parameters that apply.


# test
Command:	test - test for a condition
Syntax:		test expr
Flags:		(none)
Example:	test -r file		# see if file is readable

     Test checks to see if files exist, are readable, etc. and returns
an exit status of zero if true and nonzero if false.  The legal operators are
  -r file  true if the file is readable
  -w file  true if the file is writable
  -x file  true if the file is executable
  -f file  true if the file is not a directory
  -d file  true if the file is a directory
  -s file  true if the file exists and has a size > 0
  -t fd    true if file descriptor fd (default 1) is a terminal
  -z s     true if the string s has zero length
  -n s     true if the string s has nonzero length
  s1 = s2  true if the strings s1 and s2 are identical
  s1 != s2 true if the strings s1 and s2 are different
  m -eq m  true if the integers m and n are numerically equal
                The operators -gt, -ge, -ne, -le, -lt may be used as well

These operands may be combined with -a (Boolean and), -o (Boolean or), !
(negation).  The priority of -a is higher than that of -o.  Parentheses are 
permitted, but must be escaped to keep the shell from trying to interpret them.


# to
Command:	to - output half of a connection
Syntax:		to port
Flags:		(none)
Example:	cat f1 f2 | to mach4	# send the catted files to port

     To and from are used together to provide connection-oriented service.
On the sending machine, the last member of a pipeline is 'to port'.  On the
receiving machine, the first member of a pipe line is 'from port'.  The net
result is that the output of the sending pipeline goes into the input of the
receiving pipeline, making pipelines work across the network. As a simple
example, consider:
	on machine1:	cat f1 f2 | to Johnny
	on machine2:	from Johnny | sort >x
The effect of these two commands is that the files f1 and f2 are concatenated,
transferred to machine 2, and sorted their, with the output going to a file x
on machine 2.  The string Johnny is used by the transaction system to identify
which sender goes with which receiver; any unique string can be used.


# traverse
Command:	traverse - print directory tree under the named directory
Syntax:		traverse dir
Flags:		(none)
Example:	traverse .		# print tree starting at working dir

     Traverse prints the tree structure starting at the named directory.  All
the subdirectories are listed, with the depth shown by indentation.


# tset
Command:	tset - set the $TERM variable
Syntax:		tset [device]
Flags:		(none)
Example:	eval `tset`		# set TERM

     Tset is used almost exclusively to set the shell variable TERM from
inside profiles.  If an argument is supplied, that is used as the value of
TERM.  Otherwise it looks in /etc/ttytype.


# tsort
Command:	tsort - topological sort
Syntax:		tsort file
Flags:		(none)
Example:	ar cr libc.a `lorder *.s | tsort`	# build library

     Tsort accepts a file of lines containing ordered pairs and builds a
total ordering from the partial orderings.


# treecmp
Command:	treecmp - recursively list differences in two directory trees
Syntax:		treecmp [-v] dir1 dir2
Flags:		-v (verbose) list all directories processed
Example:	treecmp -v /usr/ast/V1 /usr/ast/V2

     Treecmp recursively descends the directory tree of its first argument
and compares all files to those at the corresponding position in the second
argument.  If the two trees are identical, i.e., all the corresponding
directories and files are the same, there is no output.  Otherwise, a list
of files missing from one of the trees or present in both but whose contents
are not identical in both are printed.


# tty
Command:	tty - print the device name of this tty
Syntax:		tty
Flags:		-s silent mode (return status only)
Example:	tty

     Print the name of the controlling tty


# vol
Command:	vol - split standard input into diskette-sized volumes
Syntax:		vol [-u] size block-special
Flags:		-u unsave from diskettes
Examples:	tar c - . | vol 360 /dev/fd0	# prompt for disk every 360K
		vol -u 360 /dev/fd0 | tar x -	# restore a saved file system

     It occasionally happens that a program generates an output stream intended
for diskette but the stream is to large to fit on one diskette.  Vol is a
program that accepts such a stream, and pauses every n blocks to request a
new diskette to be inserted.  This makes it possible to save arbitrarily long
streams on a series of diskettes, as shown in the examples above.


# whereis
Command:	whereis - examine system directories for a given file
Syntax:		whereis file
Flags:		(none)
Example:	whereis	stat.h		# prints: /usr/include/sys/stat.h

     Whereis searches a fixed set of system directories, /bin, /lib, /usr/bin,
and others, and prints all occurrences of the argument name in any of them.


# which
Command:	which - examine $PATH to see which file will be executed
Syntax:		which name
Flags:		(none)
Example:	which a.out		# tells which a.out will be executed

     The $PATH shell variable controls the MINIX search rules. If a command
a.out is given, the shell first tries to find an executable file in the working
directory.  If that fails, it looks in various system directories, such as /bin
and /usr/bin.  The which command makes the same search and gives the absolute
path of the program that will be chosen.


# who
Command:	who - print list of currently logged in users
Syntax:		who
Flags:		(none)
Example:	who			# print user names, terminals and times

     Who prints a list of currently logged in users.  For each one, the user
name, terminal, and login time is printed.  This program gets its information
from the file /usr/adm/wtmp, which is updated by init and login.  If the file
does not exist, neither of these will create it, and 'who' will not work.  Note
that if you decide to create an empty /usr/adm/wtmp to enable the login
accounting, it will grow forever and eventually fill up your disk unless you
manually truncate it from time to time.


# whoami
Command:	whoami - print current user name
Syntax:		whoami
Flags:		(none)
Example:	whoami			# print user name

     In case you forget who you are logged in as, whoami will tell you.  If
you use 'su' to become somebody else, whoami will give the current effective
user.


# uuencode
Command:	uuencode - encode a binary file to ASCII (e.g., for mailing)
Syntax:		uuencode [input] output
Flags:		(none)
Example:	uuencode infile <infile >outfile	# encode infile

     Uuencode takes an input file, typically a binary file, and converts it
to pure ASCII by encoding 3 bytes (24 bits) as 4 bytes in ASCII.  Only 64
different characters are used, all of them valid ASCII characters.


# uudecode
Command:	uudecode - decode a binary file encoded with uuencode
Syntax:		uudecode file 
Flags:		(none)
Example:	uudecode encodedfile 	# re-create the original file

     Uudecode takes an input file, typically a uuencoded binary file, and 
converts it back to the original file.  The decoded file is given the name
that the original file had.  The name information is part of the encoded file.


# write
Command:	write - write a message to a terminal
Syntax:		write ttyn
Flags:		(none)
Example:	write tty1		# write to /dev/tty1

     Write is a shell script that is used to send a message to another logged
in user on the system.  The user is identified by tty number.  After the
message has been typed, the user types CTRL-D to exit.

